<html>
    <head>
    <script src="/lib/p5/p5.min.js"></script>
        <body style="touch-action: auto; overflow: hidden; margin: 0%; padding: 0%;">
            <script>
                // (() => {
                //     window.__WEBVIEW_BRIDGE__ = {
                //         init: function() {
                //             try {
                //                 document.addEventListener('message', e => {
                //                     console.log(e);
                //                 })
                //             } catch(e) {
                //                 console.log(e);
                //             }
                //         }
                //     };
                //     window.__WEBVIEW_BRIDGE__.init();
                // })();

                // function getCookie(cookie_name) { 
                //     var x, y; 
                //     var val = document.cookie.split(';'); 
                //     for (var i = 0; i < val.length; i++) { 
                //         x = val[i].substr(0, val[i].indexOf('=')); 
                //         y = val[i].substr(val[i].indexOf('=') + 1); 
                //         x = x.replace(/^\s+|\s+$/g, ''); // 앞과 뒤의 공백 제거하기 
                //         if (x == cookie_name) { return unescape(y); // unescape로 디코딩 후 값 리턴 
                //         } 
                //     } 
                // }

                // alert(window.innerWidth + '  ' + window.innerHeight);
                // alert(getCookie('webView'));

                // e-avp 주차장 그리드 width 60, height 168
                /*
                    width 59 height 143
                    또는
                    width 143, height 59
                */
                
                // 가로 세로 cell수
                let xGridCnt = 6;
                let yGridCnt = 10;

                // let xGridCnt = 60;
                // let yGridCnt = 168;

                let aspectRatio = yGridCnt/xGridCnt;
                let reverseAspectRatio = xGridCnt/yGridCnt;

                let screenAspect = window.innerHeight / window.innerWidth;
                let reverseScreenAspect = window.innerWidth / window.innerHeight;
                
                let cnvHeight = window.innerHeight * 0.95;
                let cnvWidth = cnvHeight * reverseAspectRatio;

                if(cnvWidth > window.innerWidth) {
                    let reduceRatio = window.innerWidth / cnvWidth;
                    cnvWidth = cnvWidth * reduceRatio;
                    cnvHeight = cnvHeight * reduceRatio; 
                }

                //div 요소 위치 조정용 변수
                /*
                    각 canvas 요소위에 html div요소를 mapping하여, mouse click event를 정의한다.
                    div position 요소는 canvas요소의 좌측 margin 너비 만큼, 세로 margin만큼 더해져야 한다.
                */
                let divAdjHeight = (window.innerHeight - cnvHeight) / 2;
                let divAdjWidth = (window.innerWidth - cnvWidth) / 2;

                // let divAdjHeight = (window.innerHeight - cnvHeight) / 2;
                // let divAdjWidth = 0;

                // 한 cell 변의 길이
                let spacer = cnvHeight / yGridCnt;

                //자연수 좌표계[(0,0) (1,1)....]를 canvas의 좌표계에 mapping한다. [(0,0) (5.55, 23.34)....]
                let xCordinates = [];
                let yCordinates = [];

                //canvas에 그려전 각 cell의 중심 좌표
                let xCenters = [];
                let yCenters = [];

                for(let x = 0; x < xGridCnt; x++) {
                    xCordinates.push(x * spacer);
                    xCenters.push(x * spacer + (spacer / 2));
                }

                for(let y = 0; y < yGridCnt; y++) {
                    yCordinates.push(y * spacer);
                    yCenters.push(y * spacer + (spacer / 2))
                }

                let canvas;

                //test
                let jitter;

                let parkingAreas = [];
                let walls;

                let entrance;
                let exit;

                function setup() {

                    canvas = createCanvas(cnvWidth , cnvHeight);
                    canvas.position((window.innerWidth - cnvWidth) / 2, (window.innerHeight - cnvHeight) / 2, 'fixed');

                    jitter =  new Jitter();
                    
                    for(let i = 0; i < pStartPoints.length; i ++) {
                        parkingAreas.push(new ThreeByTwoPA(pStartPoints[i].x, pStartPoints[i].y));
                    }

                    // wall set
                    walls = new Wall();

                    // parking lot entrance
                    entrance = new Entrance();

                    // parking lot exit
                    exit = new Exit();

                }

                // let xCount = 0;
                // let yCount = 0;

                // function mousePressed(event) {
                //     console.log(event);
                //     for(let i = 0; i < parkingAreas.length; i++){
                //         parkingAreas[i].clicked();
                //     }
                // }
                
                function draw() {
                    background(255);
                    
                    push();
                    // 그리드 맵의 좌표 점찍기
                    for(let x = 0; x < width; x += spacer) {
                        for(let y = 0; y < (width * aspectRatio); y += spacer) {
                            stroke(20);
                            ellipse(x + spacer /2, y + spacer /2, 2, 2);
                        }
                    }
                    
                    // 그리드 맵의 선 그리기
                    for(let yLine = 0; yLine <= cnvHeight; yLine += spacer) {
                        stroke(0);
                        strokeWeight(0.5);
                        line(0, yLine, width, yLine);
                        line(yLine, 0, yLine, height);
                    }
                    strokeWeight(0.5);
                    line(width-1, 0, width-1, height-1);
                    line(0, height-1, width-1, height-1);
                    pop();
                    // jitter test
                    jitter.display();
                    jitter.move();

                    // parkingArea display
                    for(let i = 0; i < parkingAreas.length; i++) {
                        parkingAreas[i].display();
                    }

                    // walls display
                    walls.display();

                    // parking lot entrance display
                    entrance.display();
                    
                    // parking lot exit display
                    exit.display();

                    //noLoop(); 
                }

                class Jitter {
                    constructor() {
                        this.x = random(width);
                        this.y = random(height);
                        this.diameter = random(10, 30);
                        this.speed = 1;
                    }

                    move() {
                        this.x += random(-this.speed, this.speed);
                        this.y += random(-this.speed, this.speed);
                    }

                    display() {
                        ellipse(this.x, this.y, this.diameter, this.diameter);
                    }
                }
                
                // parking area 시작 자연수 좌표
                const pStartPoints = [
                    {
                        x: 2,
                        y: 2
                    },
                    {
                        x: 2,
                        y: 4
                    },
                    {
                        x: 2,
                        y: 6
                    }
                ];
                
                // PA => Parking Area
                class ThreeByTwoPA {
                    constructor(x, y) {
                        this.startX = xCordinates[x];
                        this.startY = yCordinates[y];

                        this.width = xCordinates[x + 3] - xCordinates[x];
                        this.height = yCordinates[y + 2] - yCordinates[y];

                        this.lineCol = color(40, 199, 69);
                        this.col = color(115, 235, 125);

                        let dom = createDiv();
                        dom.size(this.width, this.height);
                        dom.position(this.startX + divAdjWidth, this.startY + divAdjHeight);
                        // dom.addEventListener('touchstart', () => {
                        //     dom.position((window.innerWidth - cnvWidth) / 2, (window.innerHeight - cnvHeight) / 2);
                        // });
                        dom.mousePressed(() => {
                            alert('This is parking area! : ' + this.startX + ',' + this.startY);
                        });
                        this.dom = dom;

                        //this.speed = 1;
                    }
                    
                    // move() {
                    //     this.startX += random(-this.speed, this.speed);
                    //     this.startY += random(-this.speed, this.speed);
                    //     this.dom.position(this.startX + divAdjWidth, this.startY + divAdjHeight);
                    // }

                    display() {
                        push();
                        stroke(this.lineCol);
                        //stroke(51);
                        fill(this.col);
                        strokeWeight(3);
                        rect(this.startX, this.startY, this.width, this.height);
                        pop();
                    }

                    clicked() {
                        console.log('clicked'); 
                        this.col = color(255, 0, 200);   
                    }

                }

                const wallStartEndPoints =[
                    {
                        start: { x: 5, y: 0 },
                        end: { x: 5, y: 9 }
                    }
                ];

                class Wall {
                    contructor() {
                        this.walls = wallStartEndPoints;
                        this.wallsLength = wallStartEndPoints.length;
                    }

                    display() {
                        push();
                        for(let i = 0; i < wallStartEndPoints.length; i++) {
                            let wall = wallStartEndPoints[i]; 

                            for(let j = 0; j <= wall.end.x - wall.start.x; j++) {

                                for(let k = 0; k <= wall.end.y - wall.start.y; k++) {
                                    stroke(47, 48, 48);
                                    strokeWeight(2);
                                    fill(93, 97, 97);
                                    rect(xCordinates[wall.start.x + j], yCordinates[wall.start.y + k], spacer, spacer);
                                }

                            }

                        }
                        pop();
                    }
                }

                class Entrance {
                    constructor() {

                        let startX = xCordinates[5];
                        let startY = yCordinates[0];

                        let xPoints = [];
                        let yPoints = [];

                        xPoints.push(startX);
                        yPoints.push(startY);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY + (1 / 2 * spacer));

                        xPoints.push(startX - (3 / 2 * spacer) + spacer);
                        yPoints.push(startY + (1 / 2 * spacer));

                        xPoints.push(startX - (3 / 2 * spacer) + spacer);
                        yPoints.push(startY + (1 / 2 * spacer) + spacer);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY + (1 / 2 * spacer) + spacer);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY + (2 * spacer));

                        xPoints.push(startX);
                        yPoints.push(startY + (2 * spacer));

                        xPoints.push(startX);
                        yPoints.push(startY);

                        this.xPoints = xPoints;
                        this.yPoints = yPoints;

                    }

                    display() {

                        push();
                        beginShape();
                        stroke(25, 107, 230);
                        strokeWeight(2);
                        fill(99, 153, 235);
                        for(let i = 0; i < 8; i++) {
                            
                            vertex(this.xPoints[i], this.yPoints[i]);
                            
                        }
                        endShape(CLOSE);
                        pop();

                    }
                }

                class Exit {
                    constructor() {

                        let startX = xCordinates[5];
                        let startY = yCordinates[8];

                        let xPoints = [];
                        let yPoints = [];

                        xPoints.push(startX);
                        yPoints.push(startY);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY + (1 / 2 * spacer));

                        xPoints.push(startX - (3 / 2 * spacer) + spacer);
                        yPoints.push(startY + (1 / 2 * spacer));

                        xPoints.push(startX - (3 / 2 * spacer) + spacer);
                        yPoints.push(startY + (1 / 2 * spacer) + spacer);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY + (1 / 2 * spacer) + spacer);

                        xPoints.push(startX - (3 / 2 * spacer));
                        yPoints.push(startY + (2 * spacer));

                        xPoints.push(startX);
                        yPoints.push(startY + (2 * spacer));

                        xPoints.push(startX);
                        yPoints.push(startY);

                        this.xPoints = xPoints;
                        this.yPoints = yPoints;

                    }

                    display() {

                        push();
                        beginShape();
                        stroke(25, 107, 230);
                        strokeWeight(2);
                        fill(99, 153, 235);
                        for(let i = 0; i < 8; i++) {
                            
                            vertex(this.xPoints[i], this.yPoints[i]);
                            
                        }
                        endShape(CLOSE);
                        pop();

                    }
                }

                class Car {
                    constructor(startPoint, endPoint) {
                        this.uuid = 'car1';

                        this.curX = xCordinates[0] + (spacer / 2);
                        this.curY = yCordinates[0] + (spacer / 2);

                        this.currentPosition = {
                            x: this.curX,
                            y: this.curY
                        }

                        this.lastPosition = {
                            x: this.curX,
                            y: this.curY
                        }

                        // car size => 2 cell by 1 cell
                        this.length = 2 * spacer;
                        this.width = 1 * spacer;

                        this.speed = 1;
                        this.direction;
                    }

                    move() {

                    }

                    display() {

                    }
                }

            </script>
        </body>
    </head>
</html>